# coding=utf-8
# Copyright 2018 The Google AI Language Team Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Lint as: python3
r"""Converts a predictions json file to format expected for Spider evaluation.

The input to this binary is the predictions file generated by
`run_inference.py`, which contains newline separated json dictionaries with
model predictions and scores. This file currently selects the one-best
score.

The output is a newline separated text file containing the one-best predictions
and the associated database name.

Example usage:

${PATH_TO_BINARY} \
  --spider_examples_json=${SPIDER_DIR}/spider/dev.json \
  --input_path=${INPUT} \
  --output_path=${SPIDER_PREDICTIONS}

python ${SPIDER_DIR}/spider-master/evaluation.py \
  --gold "${SPIDER_DIR}/spider/dev_gold.sql" \
  --pred "${SPIDER_PREDICTIONS}" \
  --etype match \
  --db "${SPIDER_DIR}/spider/database" \
  --table "${SPIDER_DIR}/spider/tables.json"
"""

from __future__ import absolute_import
from __future__ import division

from __future__ import print_function

import json

from absl import app
from absl import flags

import tensorflow.compat.v1 as tf

FLAGS = flags.FLAGS

flags.DEFINE_string('input_path', '', 'Path to predictions.')
flags.DEFINE_string('output_path', '',
                    'Path to write Spider-formatted predictions.')
flags.DEFINE_string('spider_examples_json', '', 'Path to Spider json examples')


def _load_json(filepath):
  with tf.gfile.Open(filepath) as json_file:
    return json.load(json_file)


def _load_predictions_dicts(filepath):
  """Returns list of predictions dicts."""
  predictions_dicts = []
  with tf.gfile.Open(filepath) as input_file:
    for line in input_file:
      if not line:
        continue
      predictions_dict = json.loads(line)
      predictions_dicts.append(predictions_dict)
  return predictions_dicts


def _utterance_to_one_best_sql_map(predictions_dicts):
  """Get map of utterance to best prediction."""
  # Assume sorted in descending order by score.
  utterance_to_one_best_sql_map = {}
  for predictions_dict in predictions_dicts:
    if not predictions_dict['predictions']:
      print('No predictions for example: %s' % predictions_dict)
      continue
    utterance = predictions_dict['utterance']
    one_best_prediction = predictions_dict['predictions'][0]
    # TODO(petershaw): Stricter check here for duplicates, e.g.:
    # if utterance in utterance_to_one_best_sql_map:
    #    raise ValueError('Utterance %s already in map.' % utterance)
    utterance_to_one_best_sql_map[utterance] = one_best_prediction
  return utterance_to_one_best_sql_map


def write_predictions(input_path, output_path, spider_examples_json):
  """Writes one-best predictions in Spider-evaluation compatible format."""
  predictions_dicts = _load_predictions_dicts(input_path)
  utterance_to_one_best_sql_map = _utterance_to_one_best_sql_map(
      predictions_dicts)

  examples = _load_json(spider_examples_json)
  with tf.gfile.Open(output_path, 'w') as output_file:
    for example in examples:
      utterance = ' '.join(example['question_toks'])
      db_id = example['db_id']
      if utterance not in utterance_to_one_best_sql_map:
        print('No prediction for utterance: %s' % utterance)
        # Write a line with dummy output.
        output_file.write('SKIP\t%s\n' % db_id)
      else:
        prediction = utterance_to_one_best_sql_map[utterance]
        output_file.write('%s\t%s\n' % (prediction, db_id))


def main(unused_argv):
  write_predictions(FLAGS.input_path, FLAGS.output_path,
                    FLAGS.spider_examples_json)


if __name__ == '__main__':
  app.run(main)
